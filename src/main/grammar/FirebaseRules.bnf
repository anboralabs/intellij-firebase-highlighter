// Copyright 2000-2020 JetBrains s.r.o. and other contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
{
  parserClass="co.anbora.labs.firebase.lang.core.parser.FirebaseRulesParser"
  psiClassPrefix="FirebaseRules"
  psiImplClassSuffix="Impl"

  implements="co.anbora.labs.firebase.lang.core.psi.FirebaseElement"
  extends="co.anbora.labs.firebase.lang.core.psi.FirebaseElementImpl"

  psiPackage="co.anbora.labs.firebase.lang.core.psi"
  psiImplPackage="co.anbora.labs.firebase.lang.core.psi.impl"
  parserUtilClass="co.anbora.labs.firebase.lang.core.parser.FirebaseParserUtil"

  elementTypeHolderClass="co.anbora.labs.firebase.lang.core.psi.FirebaseRulesTypes"

  elementTypeClass="co.anbora.labs.firebase.lang.core.FirebaseElementType"
  tokenTypeClass="co.anbora.labs.firebase.lang.core.FirebaseTokenType"

  extends(".+Expr") = Expression

  name(".*Expr")="expr"

  tokens = [
          WHITE_SPACE='WHITE_SPACE'
          LP = '('
          RP = ')'
          LB = '['
          RB = ']'
          LEFT_BRACE = '{'
          RIGHT_BRACE = '}'
          number='regexp:\d+(\.\d*)?'
          string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
          SLASH = '/'
          op = '->'
          COLON = ':'
          COMMA = ','
          EQ = '='
          DOT = '.'
          Q_MARK = '?'
          DOT_COMMA = ';'
          WILD_CARD = '=**'
          MODULO         =  '%'
          char = 'regexp:[\n\r\u2028\u2029]'
          LINE_COMMENT='LINE_COMMENT'
          BLOCK_COMMENT='BLOCK_COMMENT'
          EXITS_KEYWORD   = 'exists_kw'
          GET_KEYWORD     = 'get_kw'
          READ_KEYWORD    = 'read_kw'
          WRITE_KEYWORD   = 'write_kw'
          LIST_KEYWORD    = 'list_kw'
          CREATE_KEYWORD  = 'create_kw'
          UPDATE_KEYWORD  = 'update_kw'
          DELETE_KEYWORD  = 'delete_kw'
      ]

}

root ::= !<<eof>> property
    {pin=1}

private property ::= RuleVersionDef? (FunctionDef)* ServiceDef {
    pin=1
}

// top-level recovery
private Item_first ::= function | match | service | allow
private Item_recover ::= !('}' | <<eof>> | Item_first)

RuleVersionDef ::= RULES_VERSION EQ VERSIONS DOT_COMMA {
    pin=1
}

//Service Definition Begin
ServiceDef ::= SERVICE_KEYWORD SERVICE_NAME ServiceBlock
{
    pin=1
    recoverWhile=ServiceDef_recover
}
private ServiceDef_recover ::= !(SERVICE_KEYWORD SERVICE_NAME)

ServiceBlock ::= LEFT_BRACE ServiceBlockItems RIGHT_BRACE
{
    pin=1
}
private ServiceBlockItems ::= !('}' | <<eof>>) ServiceItems+
{
    pin=1
    recoverWhile=Item_recover
}
private ServiceItems ::= MatchDef | FunctionDef
//Service Definition End

//Match Definition Begin
MatchDef ::= MATCH_KEYWORD FullPathStatement MatchBlock
{
    pin=1
}

MatchBlock ::= LEFT_BRACE MatchBlockItems RIGHT_BRACE
{
    pin=1
}
private MatchBlockItems ::= !('}' | <<eof>>) MatchItems+ {
    pin=1
    recoverWhile=Item_recover
}
private MatchItems ::= AllowStatement | MatchDef | FunctionDef

FullPathStatement ::= FullPathStatementItem+
{
    pin=1
}

private FullPathStatementItem ::= !('{') SLASH PathStatement {
    pin=1
    recoverWhile=FullPathStatementItem_recover
}
private FullPathStatementItem_recover ::= !(SLASH | '{' | IDENTIFIER | VariableInPath)
//Match Definition End

PathStatement ::= (DOT? IDENTIFIER|VariableInPath)
VariableInPath ::= PATH_VARIABLE {
    mixin="co.anbora.labs.firebase.lang.core.psi.mixings.IdentifierMixing"
}

//Allow Statement Begin
AllowStatement ::= EmptyAllowStm | ConditionalAllowStm
private EmptyAllowStm ::= ALLOW_KEYWORD PermissionStatement DOT_COMMA
private ConditionalAllowStm ::= ALLOW_KEYWORD PermissionStatement COLON ConditionalStatement DOT_COMMA

private get ::= <<getKeyword>>
private read ::= <<readKeyword>>
private write ::= <<writeKeyword>>
private list ::= <<listKeyword>>
private create ::= <<createKeyword>>
private update ::= <<updateKeyword>>
private delete ::= <<deleteKeyword>>

PermissionKeyWord ::= (get | read | write | list
                            | create | update | delete)

PermissionStatement ::= PermissionStatementItem+
{
    pin=1
}
private PermissionStatementItem ::= !(':'|';') PermissionKeyWord (',' | &(':'|';')) {
    pin=1
    recoverWhile=Permission_recover
}
private Permission_recover ::= !(':' |';' | get | read | write | list
                                     | create | update | delete)

ConditionalStatement ::= IF_KEYWORD ConditionalBlock {
    pin=1
}

ConditionalBlock ::= Expression
//Allow Statement End

FullBuiltInParameterStatement ::= (SLASH PathBuiltInParameterStatement)+

PathBuiltInParameterStatement ::= (DOT? IDENTIFIER|PATH_BUILT_IN)

//Function Definition Begin
FunctionDef ::= FUNCTION_KEYWORD IdentifierExpr FunctionParameterList FunctionBlock
{
    pin=1
}

FunctionParameterList ::= '(' FunctionParameter_with_recover* ')'
{
    pin = 1
}

private FunctionParameter_with_recover ::= !(')' | '{' | ';') FunctionParameter (',' | &')')
{
    pin = 1
    recoverWhile = FunctionParameter_recover
}
private FunctionParameter_recover ::= !(')' | '{' | ';' | IDENTIFIER)

FunctionParameter ::= IDENTIFIER
{
    pin = 1
}

FunctionBlock ::= LEFT_BRACE FunctionBlockItems RIGHT_BRACE
{
    pin = 1
}
private FunctionBlockItems ::= VariableStatement*
                               ReturnStatement
{
    recoverWhile = FunctionBlock_recover
}
private FunctionBlock_recover ::= !('}' | <<eof>>)
//Function Definition Ends

ParameterStatement ::= Expression(COMMA Expression)*

ReturnStatement ::= RETURN_KEYWORD ReturnBlock {
    pin=1
}
ReturnBlock ::= Expression DOT_COMMA

Expression ::=
        OrExpr
        | AndExpr
        | LogicalEqExprItem
        | AddExprItem
        | MulExprItem
        | TernaryExpr
        | NegateExpr
        | AtomExpr
//{ name="expr" }

ParensExpr ::= LP Expression RP
NegateExpr ::= NEGATE Expression
IndexExpr ::= Expression '[' (RangeExpr|Expression) ']'
private RangeExpr ::= Expression ':' Expression

TernaryExpr ::= Expression '?' Expression ':' Expression

IdentifierExpr ::= IDENTIFIER {
    mixin="co.anbora.labs.firebase.lang.core.psi.mixings.IdentifierMixing"
}
DotExpr ::= Expression DOT AtomExpr
CallExpr ::= Expression CallArguments
CallArguments ::= '(' ParameterStatement? ')'
//CallArguments ::= '(' (Expression &(','|')'))? ')' { pin = 1 }

StructLiteralExpr ::= '{' StructLiteralField_with_recover* '}' { pin = 1 }

private StructLiteralField_with_recover ::= !'}' StructLiteralField (',' | &'}')
{
    pin = 1
    recoverWhile = StructLiteralField_recover
}
private StructLiteralField_recover ::= !('}' | IDENTIFIER)

StructLiteralField ::= LiteralExpr StructLiteralFieldAssignment?
{
    pin = 1
}

//private StructLiteralExprField_recover ::= !(',' | '}')
StructLiteralFieldAssignment ::= ':' Expression { pin = 1 }

LiteralExpr ::= LiteralStatement
        | BooleanStatement
        | NullStatement
        | IdentifierExpr
        | FullBuiltInParameterStatement

private AtomExpr ::=
        ArrayLiteralExpr
        | CallExpr
        | ParensExpr
        | StructLiteralExpr
        | IndexExpr
        | DotExpr
        | LiteralExpr

private MulExprItem ::= DivExpr | MulExpr | ModExpr
private AddExprItem ::= PlusExpr | MinusExpr
private LogicalEqExprItem ::= EqualsExpr | NotEqualsExpr | LessEqualsExpr | LessExpr | GreaterEqualsExpr | GreaterExpr
                                | InExpr | IsExpr

InExpr ::= Expression IN_KEYWORD Expression
IsExpr ::= Expression IS_KEYWORD Expression

EqualsExpr ::= Expression EQEQ Expression
NotEqualsExpr ::= Expression NE Expression

OrExpr ::= Expression OROR Expression
AndExpr ::= Expression ANDAND Expression

LessExpr ::= Expression LT Expression
GreaterExpr ::= Expression GT Expression
LessEqualsExpr ::= Expression LE Expression
GreaterEqualsExpr ::= Expression GE Expression

DivExpr ::= Expression '/' Expression
MulExpr ::= Expression MULT_OP Expression
ModExpr ::= Expression '%' Expression

PlusExpr ::= Expression PLUS_OP Expression
MinusExpr ::= Expression MINUS_OP Expression

ArrayLiteralExpr ::= EmptyArrayExpr | ArrayExpr
private EmptyArrayExpr ::= LB RB
private ArrayExpr ::= LB (ParameterStatement) RB

LiteralStatement ::= (number|string)

VariableStatement ::= LET_KEYWORD IdentifierExpr EQ Expression (DOT_COMMA?) { pin = 1 }

NullStatement ::= NULL_KEYWORD

BooleanStatement ::= (TRUE_KEYWORD|FALSE_KEYWORD)
